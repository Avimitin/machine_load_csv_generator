#!/usr/bin/ruby

# frozen_string_literal: true

require 'csv'
require 'dotenv/load'
require 'sqlite3'
require 'time'
require 'pathname'
require 'fileutils'

#
# Configuration
#

DATA_PATH = Pathname.new(ENV['DATA_PATH'])
CSV_OUTPUT = Pathname.new(ENV['CSV_OUTPUT_DIR'])
DB_FILENAME = DATA_PATH + ENV['DB_FILENAME']
DATETIME = Time.new.strftime('%Y-%m')
HEADERS = ['DateTime', 'Logined Users', 'Machine Load'].freeze

#
# Utils function
#

Machine = Struct.new('Machine', :id, :name, :team)

def get_all_machine(db)
  db.execute('SELECT id, name, team FROM machine').collect { |row| Machine.new(row[0], row[1], row[2]) }
end

def get_data(db, machine_id)
  db
    .query(
      "SELECT DATETIME(ttime, 'unixepoch') as isodate, users, load FROM record WHERE machine=?",
      machine_id
    )
    .collect { |row| row }
end

#
# Main logic
#

db = SQLite3::Database.open(DB_FILENAME)
machines = get_all_machine(db)

machines.each do |m|
  record = get_data(db, m.id)
  prefix = CSV_OUTPUT.join("#{m.name}-#{m.team}")
  FileUtils.mkdir_p(prefix)
  filename = prefix.join("#{DATETIME}.csv")

  CSV.open(filename, 'w') do |csv|
    csv << HEADERS
    # rec[0] is test datetime, rec[1] is users, rec[2] is load
    record.each do |rec|
      # unmatched have 4 cpu cores
      rec[2] = ((rec[2] / 4) * 100).round(3)
      csv << rec
    end
  end
  puts "#{filename} generated"
end

puts 'Process done'
